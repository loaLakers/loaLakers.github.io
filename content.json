[{"title":"微服务下API设计安全","date":"2017-08-04T07:43:00.000Z","path":"2017/08/04/java-2017-0804-1543/","text":"Spring Boot作为微服务的入门级微框架，大大提高了生产力。 但安全是永恒不变的话题，本文在Spring Boot的基础上简单介绍两种常用的保证API安全的方案。 Spring Boot + Spring Security + JWT Spring Boot + API Token + Sign 开发环境java:1.8 Spring Boot:1.5.2 gradle:2.12 Spring Security结合JWTJWT工作示意图 首先在Spring Boot工程中引入Spring Security和JWT。12compile(&quot;org.springframework.boot:spring-boot-starter-security&quot;)compile group: &apos;io.jsonwebtoken&apos;, name: &apos;jjwt&apos;, version: &apos;0.7.0&apos; 新建几个API，利用Spring Security对请求进行控制，让用户在/login进行登录并获得Token，访问其他API时进行验证。例如对/api/users进行限制。 12345678910111213/** * 获取人员列表 * * @return */@RequestMapping( value = &quot;users&quot;, method = &#123;RequestMethod.POST, RequestMethod.GET&#125;, produces = &quot;application/json&quot;)public String users() &#123; return springSecurityJWTService.users();&#125; 引入一个安全设置类WebSecurityConfig，这个类需要从WebSecurityConfigurerAdapter类继承。123456789101112131415161718192021222324252627282930313233343536373839/** * @author wr * @version V1.0 * @date 2017-08-04 下午2:20 * @desc 安全设置类-所有的路由都需要身份验证 */@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; // 设置 HTTP 验证规则 @Override protected void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable() // 对请求进行认证 .authorizeRequests() // 所有 / 的所有请求 都放行 .antMatchers(&quot;/&quot;).permitAll() .antMatchers(HttpMethod.POST, &quot;/api/login&quot;).permitAll() // 添加权限检测 .antMatchers(&quot;/api/authority&quot;).hasAuthority(&quot;AUTH_WRITE&quot;) // 所有请求需要身份认证 .anyRequest().authenticated() .and() // 添加一个过滤器拦截login请求 .addFilterBefore(new JWTLoginFilter(&quot;/api/login&quot;, authenticationManager()), UsernamePasswordAuthenticationFilter.class) // 添加一个过滤器验证其他请求的Token是否合法 .addFilterBefore(new JWTAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; // 使用自定义身份验证组件 auth.authenticationProvider(new CustomAuthenticationProvider()); &#125;&#125; 设置所有人都能访问/和POST方式访问/api/login，其他的任何路由都需要进行认证。将所有访问/login的请求，都交给JWTLoginFilter过滤器来处理。 创建拦截/api/login的过滤器JWTLoginFilter。123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @author wr * @version V1.0 * @date 2017-08-04 下午2:32 * @desc 拦截所有访问 /login 的请求 */public class JWTLoginFilter extends AbstractAuthenticationProcessingFilter &#123; public JWTLoginFilter(String url, AuthenticationManager authManager) &#123; super(new AntPathRequestMatcher(url)); setAuthenticationManager(authManager); &#125; @Override public Authentication attemptAuthentication( HttpServletRequest req, HttpServletResponse res) throws AuthenticationException, IOException, ServletException &#123; // JSON反序列化成 AccountCredentials AccountCredentials creds = new ObjectMapper().readValue(req.getInputStream(), AccountCredentials.class); // 返回一个验证令牌 return getAuthenticationManager().authenticate( new UsernamePasswordAuthenticationToken( creds.getUsername(), creds.getPassword() ) ); &#125; @Override protected void successfulAuthentication( HttpServletRequest req, HttpServletResponse res, FilterChain chain, Authentication auth) throws IOException, ServletException &#123; TokenAuthenticationService.addAuthentication(res, auth.getPrincipal().toString()); &#125; @Override protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException &#123; response.setContentType(&quot;application/json&quot;); response.setStatus(HttpServletResponse.SC_OK); response.getOutputStream().println(ResultVo.fillResultString(500, &quot;Internal Server Error!!!&quot;, JSONObject.NULL)); &#125;&#125; attemptAuthentication方法是登录时需要验证时候调用，获取到登陆的用户名密码，AccountCredentials作为简单实体类负责存储用户名密码，验证过程调用自定义的CustomAuthenticationProvider。 1234567891011121314151617181920212223242526272829303132333435/** * @author wr * @version V1.0 * @date 2017-08-04 下午2:29 * @desc 自定义验证组件 */public class CustomAuthenticationProvider implements AuthenticationProvider &#123; @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; // 获取认证的用户名 &amp; 密码 String name = authentication.getPrincipal().toString(); String password = authentication.getCredentials().toString(); // 认证逻辑 if (name.equals(&quot;admin&quot;) &amp;&amp; password.equals(&quot;123456&quot;)) &#123; // 这里设置权限和角色 ArrayList&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); authorities.add(new GrantedAuthorityImpl(&quot;ROLE_ADMIN&quot;)); authorities.add(new GrantedAuthorityImpl(&quot;AUTH_WRITE&quot;)); // 生成令牌 Authentication auth = new UsernamePasswordAuthenticationToken(name, password, authorities); return auth; &#125; else &#123; throw new BadCredentialsException(&quot;密码错误&quot;); &#125; &#125; // 是否可以提供输入类型的认证服务 @Override public boolean supports(Class&lt;?&gt; authentication) &#123; return authentication.equals(UsernamePasswordAuthenticationToken.class); &#125;&#125; 其中GrantedAuthorityImpl继承自GrantedAuthority，负责权限存储。 12345678910111213141516171819202122/** * @author wr * @version V1.0 * @date 2017-08-04 下午2:25 * @desc 权限类型，负责存储权限和角色 */public class GrantedAuthorityImpl implements GrantedAuthority &#123; private String authority; public GrantedAuthorityImpl(String authority) &#123; this.authority = authority; &#125; public void setAuthority(String authority) &#123; this.authority = authority; &#125; @Override public String getAuthority() &#123; return this.authority; &#125;&#125; 当在CustomAuthenticationProvider中认证成功后，调用JWTLoginFilter的successfulAuthentication方法生成JWT。 创建JWT服务TokenAuthenticationService。该类主要负责/api/login请求验证通过之后生成JWT和其他请求访问时的JWT验证。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * @author wr * @version V1.0 * @date 2017-08-04 下午2:26 * @desc JWT生成和验签 */public class TokenAuthenticationService &#123; static final long EXPIRATIONTIME = 300000; // 5分 static final String SECRET = &quot;P@ssw02d&quot;; // JWT密码 static final String TOKEN_PREFIX = &quot;Bearer&quot;; // Token前缀 static final String HEADER_STRING = &quot;Authorization&quot;;// 存放Token的Header Key /** * 生成 * * @param response * @param username */ public static void addAuthentication(HttpServletResponse response, String username) &#123; // 生成JWT String JWT = Jwts.builder() // 保存权限（角色） .claim(&quot;authorities&quot;, &quot;ROLE_ADMIN,AUTH_WRITE&quot;) // 用户名写入标题 .setSubject(username) // 有效期设置 .setExpiration(new Date(System.currentTimeMillis() + EXPIRATIONTIME)) // 签名设置 .signWith(SignatureAlgorithm.HS512, SECRET) .compact(); // 将 JWT 写入 body try &#123; response.setContentType(&quot;application/json&quot;); response.setStatus(HttpServletResponse.SC_OK); response.getOutputStream().println(ResultVo.fillResultString(0, &quot;&quot;, JWT)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 验证 * * @param request * @return */ public static Authentication getAuthentication(HttpServletRequest request) &#123; // 从Header中拿到token String token = request.getHeader(HEADER_STRING); if (token != null) &#123; // 解析 Token Claims claims = Jwts.parser() // 验签 .setSigningKey(SECRET) // 去掉 Bearer .parseClaimsJws(token.replace(TOKEN_PREFIX, &quot;&quot;)) .getBody(); // 拿用户名 String user = claims.getSubject(); // 得到 权限（角色） List&lt;GrantedAuthority&gt; authorities = AuthorityUtils.commaSeparatedStringToAuthorityList((String) claims.get(&quot;authorities&quot;)); // 返回验证令牌 return user != null ? new UsernamePasswordAuthenticationToken(user, null, authorities) : null; &#125; return null; &#125;&#125; 非/api/login请求的验证JWTAuthenticationFilter。他负责拦截所有需要JWT的请求，然后调用TokenAuthenticationService类的静态方法去做JWT验证。 123456789101112131415161718/** * @author wr * @version V1.0 * @date 2017-08-04 下午2:34 * @desc 拦截所有需要JWT的请求，然后调用TokenAuthenticationService类的静态方法去做JWT验证 */public class JWTAuthenticationFilter extends GenericFilterBean &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)throws IOException, ServletException &#123; Authentication authentication = TokenAuthenticationService.getAuthentication((HttpServletRequest) request); SecurityContextHolder.getContext().setAuthentication(authentication); filterChain.doFilter(request, response); &#125;&#125; Postman测试首先上传用户名密码访问/api/login获取token，API接口以RESTFUL的形式，上传json。请求头 请求数据以json形式 返回数据 12345&#123; &quot;msg&quot;: &quot;&quot;, &quot;no&quot;: 0, &quot;obj&quot;: &quot;eyJhbGciOiJIUzUxMiJ9.eyJhdXRob3JpdGllcyI6IlJPTEVfQURNSU4sQVVUSF9XUklURSIsInN1YiI6ImFkbWluIiwiZXhwIjoxNTAxODM2NjY0fQ.73G37F-zndIv1OFUYBrVzzuKJ5ZdM3804EzbCTs6N0M65BlZEgsaBKKCuEchGQ6Q9_hNpHttafCMnz8W1N5z_g&quot;&#125; 访问受限制的/api/users接口，如果不以jwt方式传token的话返回数据如下 1234567&#123; &quot;timestamp&quot;: 1501836297647, &quot;status&quot;: 403, &quot;error&quot;: &quot;Forbidden&quot;, &quot;message&quot;: &quot;Access Denied&quot;, &quot;path&quot;: &quot;/nginxhttps/api/users&quot;&#125; 添加header之后，访问 由于在TokenAuthenticationService方法中设置了Token超时时间为5分钟，5分钟之后再访问会显示超时失效。 12345678&#123; &quot;timestamp&quot;: 1501836914856, &quot;status&quot;: 500, &quot;error&quot;: &quot;Internal Server Error&quot;, &quot;exception&quot;: &quot;io.jsonwebtoken.ExpiredJwtException&quot;, &quot;message&quot;: &quot;JWT expired at 2017-08-04T16:51:04Z. Current time: 2017-08-04T16:55:14Z, a difference of 250833 milliseconds. Allowed clock skew: 0 milliseconds.&quot;, &quot;path&quot;: &quot;/nginxhttps/api/users&quot;&#125; 程序整体运行流程 先程序启动 - main函数 注册验证组件 - WebSecurityConfig类configure(AuthenticationManagerBuilder auth)方法 设置验证规则 - WebSecurityConfig类configure(HttpSecurity http)方法 初始化过滤组件 - JWTLoginFilter和JWTAuthenticationFilter类会初始化 请求/api/login时 拿到传入JSON，解析用户名密码 - JWTLoginFilter类attemptAuthentication方法 自定义身份认证验证组件，进行身份认证 - CustomAuthenticationProvider类authenticate方法 验证成功 - JWTLoginFilter类successfulAuthentication方法 生成JWT - TokenAuthenticationService类addAuthentication方法 请求其他api验证token 接到请求进行拦截 - JWTAuthenticationFilter中的方法 验证JWT - TokenAuthenticationService类getAuthentication方法 访问Controller API Token结合签名Sign这种方式并不使用Spring Security而是将Token结合时间戳进行签名认证的方式。 首次登陆验证需要用户名密码信息服务器验证通过之后，返回客户端当前时间戳、Token值（唯一码）以及根据时间戳、Token值生成的签名。 并在服务端存储该用户和Token的对应关系，本文采用Redis。 1234String timestamp = TimeUtil.dateToStamp();String token = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);String sign = MD5Util.getPwd(timestamp + token).toUpperCase();RedisUtil.getJedis().set(name, token); 访问其他API需要同时上传时间戳、Token验证首先验证时间戳，设置超时时间， 然后验证Token值， 最后验证签名。 123456789101112131415161718192021222324252627282930313233343536373839String name = request.getParameter(&quot;name&quot;);String timestamp = request.getParameter(&quot;timestamp&quot;);String token = request.getParameter(&quot;token&quot;);String sign = request.getParameter(&quot;sign&quot;);//第一步，判断是否包含timestamp，token，sign参数，如果不含有返回错误码。if (timestamp == null || token == null || sign == null) &#123; response.getWriter().write(StringUtil.getResult(-1, &quot;请输入正确的参数&quot;, null));&#125; else &#123; String date = TimeUtil.stampToDate(timestamp); long hour = TimeUtil.timeDiff(date); //第二步，判断服务器接到请求的时间和参数中的时间戳是否相差很长一段时间，如果超过则说明该url已经过期（如果url被盗，他改变了时间戳，但是会导致sign签名不相等）。 if (hour &gt; 60) &#123; RedisUtil.getJedis().set(name, &quot;&quot;); response.getWriter().write(StringUtil.getResult(-2, &quot;验证已过期，请重新登陆&quot;, null)); &#125; else &#123; //第三步，判断token是否有效，根据请求过来的token查询，如果获取不到这说明该token已过期。 if (!RedisUtil.getJedis().get(name).equals(token)) &#123; response.getWriter().write(StringUtil.getResult(-3, &quot;验证失败，请重新登陆&quot;, null)); &#125; else &#123; String signServer = MD5Util.getPwd(timestamp + token).toUpperCase(); //第四步，对比签名 if (!signServer.equals(sign)) &#123; response.getWriter().write(StringUtil.getResult(-4, &quot;签名错误，非法登陆&quot;, null)); &#125; else &#123; chain.doFilter(request, response); &#125; &#125; &#125;&#125; —— END. loaLakers on 07.22","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Oracle数据库数据表同步","date":"2017-08-01T07:08:00.000Z","path":"2017/08/01/database-2017-0801-1508/","text":"项目中需要实现两个oracle数据库的表同步，即地方库有数据后，中间库对应的表中要有同样的数据。 对于DBA而言，首先想到的肯定是ORACLE的DG和GOLDENGATE之类的解决方案，对于程序员而言，第一，JDBC解决，第二，DBLink+触发器。 由于数据量不大，采用第二种方式。 开发环境Oracle:11g 创建DBLink在地方库创建Dblink 123456789create database link TOTEST connect to test identified by test using &apos;(DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.3.15)(PORT = 1521)) ) (CONNECT_DATA = (SERVICE_NAME = orcl) ) )&apos; 创建完成之后，测试 1select * from TEST.ACCESS_TEST@TOTEST; 如果创建成功，在地方库通过DBLink可以访问中间库的数据表。 创建同义词为了方便创建同义词 12create or replace synonym TEST_SYfor TEST.ACCESS_TEST@TOTEST; 测试同义词1select * from TEST_SY; 如果创建成功，可以看到和上一步同样的结果。 创建触发器当地方库ACCESS_TEST表插入数据的时候，同样向中间库插入数据。1234567CREATE OR REPLACE TRIGGER TRI_TESTBEFORE INSERT ON ACCESS_TEST FOR EACH ROWBEGIN INSERT INTO TEST_SY(WH,VALUE,SJ,ZLC,ACCESSID) VALUES (:NEW.WH,:NEW.VALUE,:NEW.SJ,:NEW.ZLC,:NEW.ACCESSID);END TRI_TEST; —— END. loaLakers on 08.01","tags":[{"name":"Database","slug":"Database","permalink":"http://yoursite.com/tags/Database/"}]},{"title":"Nginx搭建https服务器","date":"2017-07-28T05:55:00.000Z","path":"2017/07/28/nginx-2017-0728-1355/","text":"开发需要搭建https环境，自建证书，采用Nginx搭建。 开发环境Ubuntu:16.04.2java:1.8.0_111nginx:1.12.0OpenSSL:1.0.2g 生成证书 进入Nginx配置目录1cd /usr/local/nginx/conf/ 设置server.key 1openssl genrsa -des3 -out server.key 1024 参数设置 1openssl req -new -key server.key -out server.csr 写RSA秘钥 1openssl rsa -in server.key -out server_nopwd.key 获取私钥 1openssl x509 -req -days 365 -in server.csr -signkey server_nopwd.key -out server.crt 完成之后会在当前目录中生成server.crt、server.csr、server.key和server_nopwd.key四个文件。 配置Nginx编辑nginx.conf文件。1234567891011121314151617181920server &#123; listen 443; ssl on; #server_name localhost; ssl_certificate /usr/local/nginx/conf/server.crt; ssl_certificate_key /usr/local/nginx/conf/server_nopwd.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; #root html; #index index.html index.htm; proxy_pass http://localhost:7009/; &#125; &#125; ssl_certificate和ssl_certificate_key配置刚才生成的文件路径。 proxy_pass是将https的请求转到http://localhost:7009/。 浏览器测试首先测试http访问，即上面的7009端口访问。 换成https访问 Android端访问证书使用上述生成的自签名的服务器证书server.crt生成对应的bks证书文件。 要生成bks证书，需要bcprov-ext-jdk15on-157.jar（下载地址），且将该文件放到/jdk1.8.0_111/jre/lib/ext目录下。 使用下面命令 1keytool -genkeypair -ext SAN=IP:47.93.253.45 -importcert -trustcacerts -alias macnginx -keystore /usr/local/nginx/conf/nginx.bks -file /usr/local/nginx/conf/server.crt -storetype BKS -provider org.bouncycastle.jce.provider.BouncyCastleProvider 这样在当前目录会生成nginx.bks文件。 Android测试 将nginx.bks文件放在res/raw/目录下。 https证书校验代码 OkHttpClient设置 界面展示代码 IOS端证书访问 使用下面命令生成cer证书 1openssl x509 -in server.crt -out nginx.cer -outform der 生成证书后将nginx.cer拖入IOS工程中 123456789101112131415161718#pragma mark - 设置证书- (AFSecurityPolicy*)customSecurityPolicy&#123; /**** SSL Pinning ****/ NSString *cerPath = [[NSBundle mainBundle] pathForResource:@&quot;nginx&quot; ofType:@&quot;cer&quot;]; NSData *certData = [NSData dataWithContentsOfFile:cerPath]; //AFSSLPinningModeCertificate 使用证书验证模式 AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate]; //allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO //如果是需要验证自建证书，需要设置为YES securityPolicy.allowInvalidCertificates = YES; securityPolicy.validatesDomainName = NO; NSSet *set = [[NSSet alloc] initWithObjects:certData, nil]; securityPolicy.pinnedCertificates = set; /**** SSL Pinning ****/ return securityPolicy;&#125; 配置123AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];[manager setSecurityPolicy:[self customSecurityPolicy]]; —— END. loaLakers on 07.28","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"Android使用Jenkins实现自动化打包","date":"2017-07-22T00:53:00.000Z","path":"2017/07/22/android-2017-0722-0853/","text":"Android项目开发过程中，每次测试打包都会浪费较长的时间，为了能节省时间、将精力更多的放在代码编写上，可利用Jenkins工具进行自动化构建打包，当仓库中的代码有变化时，自动构建打包，节省时间也是迈出开发自动化的第一步。 开发环境Mac OS:10.11.6Android Studio:2.3.3adb:1.0.36gradle:3.5jenkins:2.70 运行JenkinsJenkins安装完成之后，直接命令行中运行jenkins命令即可，运行成功之后在浏览器中输入http://localhost:8080/。 配置Jenkins插件第一次运行会提示安装插件，选择推荐安装即可。 安装完成之后，提示设置用户名、密码等信息。 除了推荐安装的插件之外，Android实现自动构建还需要另外一个插件Android Lint，需要手动安装。系统设置—插件管理，搜索安装即可。 设置sdk路径系统管理—系统设置—全局属性，新建属性，输入key值和value值，其中key值必须为ANDROID_HOME。 新建项目在此之前，需要在github上或者内网git仓库新建项目，此例中使用github。地址：https://github.com/loaLakers/HelloWorld.git。 在源码管理中配置git仓库地址及密码等验证信息。 立即构建点击立即构建，会在本地生成构建成功的项目文件。 文件目录地址可在系统配置-主目录中查看 gradle编译配置Android项目需要打包还需要配置gradle，点击MyView-helloworld进入项目详情，点击配置，在构建模块设置。 打包再次点击立即构建，会在本地的目录下生成APK文件。 签名打包之前的打包是没有签名的，需要在工程的build.gradle中设置签名来自动签名打包。 将代码提交到github后，再次点击立即构建，可在相同的目录下生成已经签名的APK文件，并且名称按照设置规定的形式。 自动定时检测打包Jenkins可以设置定时检查git仓库是否有更新，如有更新自动构建打包，实现自动化。点击MyView，点击helloworld项目，点击配置，在构建触发器模块设置。 gradle.build配置代码1signingConfigs &#123;//签名的配置 release &#123; storeFile file(&quot;test.jks&quot;) storePassword &apos;123456&apos; keyAlias &apos;test&apos; keyPassword &apos;123456&apos; &#125; &#125; applicationVariants.all &#123; variant -&gt; if (variant.buildType.name == &apos;release&apos;) &#123; variant.outputs.each &#123; output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) &#123; def fileName = &quot;$&#123;releaseTime()&#125;_com.wzh_helloworld_$&#123;defaultConfig.versionName&#125;.apk&quot; output.outputFile = new File(outputFile.parent, fileName) &#125; &#125; &#125; &#125; signingConfig signingConfigs.release applicationVariants.all &#123; variant -&gt; if (variant.buildType.name == &apos;release&apos;) &#123; variant.outputs.each &#123; output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) &#123; def fileName = &quot;$&#123;releaseTime()&#125;_com.wzh_helloworld_$&#123;defaultConfig.versionName&#125;.apk&quot; output.outputFile = new File(outputFile.parent, fileName) &#125; &#125; &#125; &#125; lintOptions &#123; abortOnError false &#125; def releaseTime() &#123; return new Date().format(&quot;yyyy-MM-dd-HH:mm:ss&quot;, TimeZone.getTimeZone(&quot;Asia/Chongqing&quot;)) &#125; —— END. loaLakers on 07.22","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"oracle数据库监控","date":"2017-07-20T03:06:00.000Z","path":"2017/07/20/database-2017-0720-1106/","text":"基于jdbc,简易oracle监控。 —— END. loaLakers on 07.20","tags":[{"name":"Database","slug":"Database","permalink":"http://yoursite.com/tags/Database/"}]},{"title":"早游校园","date":"2017-07-10T23:46:00.000Z","path":"2017/07/11/other-2017-0711-0746/","text":"今天高温，早起带小子宁出去溜达溜达，小家伙挺高兴。 妈妈和宝宝 一家三口 —— END. loaLakers on 07.11","tags":[{"name":"Other","slug":"Other","permalink":"http://yoursite.com/tags/Other/"}]},{"title":"寄生活费的父亲","date":"2017-07-10T04:00:00.000Z","path":"2017/07/10/other-2017-0710-1200/","text":"在银行，看到一位父亲，将零钱叠在一起，满手操劳的手茧。 “这是存钱吗？”“给读大学的儿子寄生活费。” –来自今日头条。 —— END. loaLakers on 07.10","tags":[{"name":"Other","slug":"Other","permalink":"http://yoursite.com/tags/Other/"}]},{"title":"PHP-表格数据","date":"2017-07-10T01:36:00.000Z","path":"2017/07/10/php-2017-0710-0950/","text":"之前都是使用jsp来写动态页面。刚刚接触PHP。主要是如上所示的图标展示，从数据库获取数据展示。 表格控件使用的是sChart。 数据库链接1234567891011&lt;?php$host=&quot;*.*.*.*&quot;;$db_user=&quot;root&quot;;$db_pass=&quot;root&quot;;$db_name=&quot;ubuntu&quot;;$timezone=&quot;Asia/Shanghai&quot;;$link=mysql_connect($host,$db_user,$db_pass);mysql_select_db($db_name,$link);mysql_query(&quot;SET names UTF8&quot;);?&gt; 数据获取1234567891011121314151617181920212223&lt;?php include_once(&apos;connect.php&apos;); $res = mysql_query(&quot;select * from chart_pie where type = &apos;8&apos;&quot;); while($row = mysql_fetch_array($res))&#123; $arr[] = array( &quot;name&quot; =&gt; $row[&apos;title&apos;], &quot;value&quot; =&gt; intval($row[&apos;pv&apos;]) ); &#125; $res2 = mysql_query(&quot;select * from chart_pie where type = &apos;9&apos;&quot;); while($row2 = mysql_fetch_array($res2))&#123; $arr2[] = array( &quot;name&quot; =&gt; $row2[&apos;title&apos;], &quot;value&quot; =&gt; intval($row2[&apos;pv&apos;]) ); &#125; $data = json_encode($arr); $data2 = json_encode($arr2); //echo $data;?&gt; 页面展示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;手机税税通申报情况&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no&quot;&gt; &lt;style&gt; .main&#123; padding: 0px; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2 align=&apos;center&apos;&gt;手机税税通申报情况&lt;/h2&gt; &lt;div class=&quot;main&quot;&gt; &lt;canvas id=&quot;canvas0&quot; width=&quot;1304&quot; height=&quot;350&quot;&gt;&lt;/canvas&gt; &lt;canvas id=&quot;canvas1&quot; width=&quot;650&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt; &lt;canvas id=&quot;canvas2&quot; width=&quot;650&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script src=&quot;sChart.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var data1 = &lt;?php echo $data;?&gt;; var data2 = &lt;?php echo $data2;?&gt;; new sChart(&apos;canvas0&apos;, &apos;line&apos;, data1, &#123; title: &apos;手机税税通7月份申报情况-分区市&apos;, bgColor: &apos;#829dda&apos;, titleColor: &apos;#ffffff&apos;, fillColor: &apos;#72f6ff&apos;, axisColor: &apos;#eeeeee&apos;, contentColor: &apos;#bbbbbb&apos; &#125;); new sChart(&apos;canvas1&apos;, &apos;bar&apos;, data1, &#123; title: &apos;手机税税通7月份申报情况-分区市&apos;, bgColor: &apos;#829dda&apos;, titleColor: &apos;#ffffff&apos;, fillColor: &apos;#72f6ff&apos;, axisColor: &apos;#eeeeee&apos;, contentColor: &apos;#bbbbbb&apos; &#125;); new sChart(&apos;canvas2&apos;, &apos;pie&apos;, data2, &#123; title: &apos;手机税税通7月份申报情况-客户端&apos;, bgColor: &apos;#829dda&apos;, titleColor: &apos;#ffffff&apos;, legendColor: &apos;#ffffff&apos; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; —— END. loaLakers on 07.10","tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]}]